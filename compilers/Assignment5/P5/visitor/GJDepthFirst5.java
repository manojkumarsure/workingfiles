//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   basicblock currblock;
	procedure currproc;
	public static HashMap<Integer,tempvariable> deftemps = new HashMap<Integer,tempvariable>();
	public static HashMap<String,procedure> defprocs = new HashMap<String,procedure>();
	public static HashMap<String,basicblock> deflabels = new HashMap<String,basicblock>();
	public static HashMap<String,ArrayList<basicblock>> tofill = new HashMap<String,ArrayList<basicblock>>();
	public static ArrayList<tempvariable> alltemps = new ArrayList<tempvariable>();
	int use=0;
	int linenumber=0;
	basicblock  prevblock;
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      Integer a=0;
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
            a++;
         }
         return (R)a;
      }
      else
         return (R)a;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
      {
		linenumber+=1;
		R a = n.node.accept(this,argu);
		currblock = new basicblock(linenumber);
		currproc.method.add(currblock);
		if(tofill.get(a.toString())!=null)
		{
			for(basicblock i : tofill.get(a.toString()))
			{
				i.succ.add(currblock);
				currblock.prev.add(i);
			}
		}
		deflabels.put(a.toString(),currblock);
		if(prevblock!=null)
		{
			currblock.prev.add(prevblock);
			prevblock.succ.add(currblock);
		}
         return a;
      }
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //
   public boolean compare(ArrayList<tempvariable> t1,ArrayList<tempvariable> t2)
   {
		if (t1.size()!=t2.size())
			return false;
		int x;
		for(tempvariable t : t1)
		{
			x=0;
			for(tempvariable s : t2)
			{
				if(t==s)
				{
					x=1;
					break;
				}
			}
			if(x!=1)
				return false;
		}
		return true;
   }
   public void liveinpoutp()
   {
	int a=0;
	for(String str : defprocs.keySet())
	{
		procedure p = defprocs.get(str);
		while(true)
		{
			a=0;
			for(basicblock b:p.method)
			{
				b.liveintemp = new ArrayList<tempvariable>(b.livein);
				b.liveouttemp = new ArrayList<tempvariable>(b.liveout);
				ArrayList<tempvariable> temp = new ArrayList<tempvariable>(b.liveout);
				temp.removeAll(b.defined);
				ArrayList<tempvariable> temp2 = new ArrayList<tempvariable>();;
				ArrayList<tempvariable> temp3 = new ArrayList<tempvariable>(b.used);
				temp3.removeAll(temp);
				temp3.addAll(temp);
				b.livein = temp3;
				for(basicblock s : b.succ)
				{
					temp2.removeAll(s.livein);
					temp2.addAll(s.livein);
				}
				b.liveout = temp2;
			}
			for(basicblock b:p.method){
			if(!(compare(b.liveintemp,b.livein) && compare(b.liveouttemp,b.liveout)))
				{a=1;
				break;}}
			if(a==0)
				break;
		}
	}
	liveranges();
   }
   public void liveranges()
	{
		int x=0;
		tempvariable temp;
		for(tempvariable k : alltemps)
		{
			temp=k;
			for(basicblock b : (defprocs.get(temp.ProcedureName)).method)
			{
				x=b.linenumber;
				if(b.livein.contains(temp) && temp.end < x)
				{
					temp.end=x;
				}
				if(b.liveout.contains(temp) && temp.start > x)
				{
					temp.start=x;
				}
			}
		}
		x=0;
		for(tempvariable k : alltemps)
		{
			temp=k;
			for(basicblock b : defprocs.get(temp.ProcedureName).method)
			{
				x=b.linenumber;
				if(b.used.contains(temp) && temp.end < x)
				{
					temp.end=x;
				}
				if(b.defined.contains(temp) && temp.start > x)
				{
					temp.start=x;
				}
			}
		}
		for(tempvariable k : alltemps)
		{
			temp=k;
			if(temp.start == 99999999)
			{
				temp.start = defprocs.get(temp.ProcedureName).start;
			}
			if(temp.end == -1 )
			{
				temp.end = defprocs.get(temp.ProcedureName).end;
			}
		}
		linearscan();
	}
	public void printliveranges(ArrayList<tempvariable> l)
	{
		tempvariable temp;
		for(tempvariable k: l)
		{
			System.out.println("TEMP "+k.tempnumber+" - "+k.start+" "+k.end);
		}
	}
	public ArrayList<tempvariable> sort(ArrayList<tempvariable> list)
	{
		ArrayList<tempvariable> temp = new ArrayList<tempvariable>(list);
		ArrayList<tempvariable> sortlist = new ArrayList<tempvariable>();
		tempvariable min;
		while(temp.size()!=0)
		{
			int i;
			min=new tempvariable(0,"");
			for(tempvariable k:temp)
			{
				if(min.start >= k.start)
				{
					min=k;
				}
			}
			sortlist.add(min);
			temp.remove(min);
		}
		return sortlist;
	}
	public ArrayList<tempvariable> sortend(ArrayList<tempvariable> list)
	{
		ArrayList<tempvariable> temp = new ArrayList<tempvariable>(list);
		ArrayList<tempvariable> sortlist = new ArrayList<tempvariable>();
		tempvariable min;
		while(temp.size()!=0)
		{
			int i;
			min=new tempvariable(0,"");
			min.end=99999999;
			for(tempvariable k:temp)
			{
				if(min.end >= k.end)
				{
					min=k;
				}
			}
			sortlist.add(min);
			temp.remove(min);
		}
		return sortlist;
	}
	ArrayList<tempvariable> active = new ArrayList<tempvariable>();
	Stack<String> regstack = new Stack<String>();
	public static ArrayList<tempvariable> templist= new ArrayList<tempvariable>();
	int stackloc=0;
	public void linearscan()
	{
		ArrayList<tempvariable> sortlist=sort(alltemps);
		regstack.push("s0");
		regstack.push("s1");
		regstack.push("s2");
		regstack.push("s3");
		regstack.push("s4");
		regstack.push("s5");
		regstack.push("s6");
		regstack.push("s7");
		regstack.push("t0");
		regstack.push("t1");
		regstack.push("t2");
		regstack.push("t3");
		regstack.push("t4");
		regstack.push("t5");
		regstack.push("t6");
		regstack.push("t7");
		regstack.push("t8");
		regstack.push("t9");
		for(tempvariable i : sortlist)
		{
			expireoldintervals(i);
			if(active.size()==18)
				spillatinterval(i);
			else
			{
				i.Allotreg=regstack.peek();
				active.add(i);
				active=sortend(active);
				regstack.pop();
			}
		}
		for(tempvariable i : sortlist )
		{
// 			System.out.println("TEMP "+i.tempnumber+"-"+i.Allotreg);
		}
		templist = sortlist;
	}
	public void expireoldintervals(tempvariable i)
	{
		int l=active.size();
		int m=0;
		tempvariable j;
		while(m<l)
		{
			j=active.get(0);
			if(j.end >= i.start )
				return;
			regstack.push(j.Allotreg);
			active.remove(j);
			m++;
		}
	}
	public void spillatinterval(tempvariable i)
	{
		tempvariable spill = new tempvariable(0,"");
		for(tempvariable j: active)
		{
			spill = j;
		}
		if(spill.end > i.end)
		{
			i.Allotreg = spill.Allotreg;
			spill.location = stackloc;
			stackloc+=1;
			active.remove(spill);
			active.add(i);
			active = sortend(active);
		}
		else
		{
			i.location=1;
		}
	}
   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      linenumber+=1;
      n.f0.accept(this, argu);
       linenumber+=1;
       procedure temp = new procedure("MAIN");
       linenumber+=1;
       temp.a=0;
       currproc=temp;
       temp.start=linenumber;
       n.f1.accept(this, argu);
      n.f2.accept(this, argu);
       linenumber+=1;
       currproc=null;
       temp.end = linenumber;
       defprocs.put("MAIN",temp);
      n.f3.accept(this, argu);
       linenumber+=1;
      n.f4.accept(this, argu);
      liveinpoutp();
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      linenumber+=1;
      R a = n.f0.accept(this, argu);
      procedure temp = new procedure(a.toString());
       n.f1.accept(this, argu);
      R b = n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      temp.start = linenumber;
      temp.a=Integer.parseInt(b.toString());
      currproc=temp;
      linenumber+=1;
      deftemps.clear();
      n.f4.accept(this, argu);
      temp.end=linenumber;
      defprocs.put(a.toString(),temp);
      currproc=null;
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      prevblock = currblock;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      prevblock = currblock;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      n.f0.accept(this, argu);
      use=1;
      n.f1.accept(this, argu);
      R a = n.f2.accept(this, argu);
          if(deflabels.get(a.toString())!=null)
      {
		currblock.succ.add(deflabels.get(a.toString()));
		deflabels.get(a.toString()).prev.add(currblock);
      }
      else
      {
		if(tofill.get(a.toString())!=null)
			tofill.get(a.toString()).add(currblock);
		else
		{
			tofill.put(a.toString(),new ArrayList<basicblock>());
			tofill.get(a.toString()).add(currblock);
		}
      }
      prevblock=currblock;
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      n.f0.accept(this, argu);
      R a = n.f1.accept(this, argu);
      if(deflabels.get(a.toString())!=null)
      {
		currblock.succ.add(deflabels.get(a.toString()));
		deflabels.get(a.toString()).prev.add(currblock);
      }
      else
      {
		if(tofill.get(a.toString())!=null)
			tofill.get(a.toString()).add(currblock);
		else
		{
			tofill.put(a.toString(),new ArrayList<basicblock>());
			tofill.get(a.toString()).add(currblock);
		}
      }
      prevblock=null;
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      prevblock = currblock;
      n.f0.accept(this, argu);
      use=1;
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      use=1;
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      prevblock = currblock;
      n.f0.accept(this, argu);
      use=0;
      n.f1.accept(this, argu);
      use=1;
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      prevblock = currblock;
      n.f0.accept(this, argu);
      use=0;
      n.f1.accept(this, argu);
      use=1;
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      linenumber+=1;
      n.f0.accept(this, argu);
      use=1;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      if(prevblock!=null)
      {
		currblock.prev.add(prevblock);
		prevblock.succ.add(currblock);
      }
      prevblock = currblock;
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      linenumber+=1;
      n.f0.accept(this, argu);
      linenumber+=1;
      basicblock temp;
      currblock = new basicblock(linenumber);
      currproc.method.add(currblock);
      prevblock = currblock;
      n.f1.accept(this, argu);
      linenumber+=1;
      n.f2.accept(this, argu);
      use=1;
      linenumber+=1;
      n.f3.accept(this, argu);
      linenumber+=1;
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use =1;
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      use=1;
      R a = n.f3.accept(this, argu);
       if (currproc.b < Integer.parseInt(a.toString()))
		currproc.b=Integer.parseInt(a.toString());
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use=1;
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use=1;
      n.f1.accept(this, argu);
      use=1;
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      R a = n.f1.accept(this, argu);
      int num = Integer.parseInt(a.toString());
      tempvariable x= new tempvariable(num,currproc.procname);
      if(deftemps.get(num)!=null)
		x=deftemps.get(num);
	  else
	  {
		deftemps.put(num,x);
		alltemps.add(x);
	}
      if(use==1)
		currblock.used.add(x);
	  if(use==0)
		currblock.defined.add(x);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R)n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R)n.f0.tokenImage;
      return _ret;
   }

}
